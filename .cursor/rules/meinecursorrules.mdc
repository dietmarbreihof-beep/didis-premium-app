
description:
globs:
alwaysApply: true

# Cursor Rules für PROJEKT: Didis Trading Academy - Flask Premium Frontend

---

## ⚠️ **KRITISCH: CLAUDE CODE HAT VORRANG**

**Diese Rules enthalten kritische Änderungen durch Claude Code (`claude/prepare-production-release-011CURveFMwP9fPGmGZ2NeWN`).
Claude Code Implementierungen haben ABSOLUTE PRIORITÄT und dürfen NICHT durch Cursor überschrieben werden!**

---

## 🚨 **KRITISCHE REGELN VON CLAUDE CODE - NIEMALS ÄNDERN**

### 1. ❌ AUTO-SYNC IST PERMANENT DEAKTIVIERT

**Was Claude Code geändert hat:**
- `init_modules_on_startup()` (app.py:209-212) hat ein **Early Return** und ist deaktiviert
- `sync_modules_from_local()` wird NICHT mehr in Routes aufgerufen
- **Grund:** Auto-Sync hat User-erstellte Module überschrieben

**CURSOR DARF ABSOLUT NICHT:**
- ❌ Auto-Sync reaktivieren
- ❌ Early Return in `init_modules_on_startup()` entfernen
- ❌ `sync_modules_from_local()` in Routes aufrufen
- ❌ Module programmatisch synchronisieren

**CURSOR MUSS:**
- ✅ Module NUR über Admin-UI oder `/admin/register-missing-modules` verwalten
- ✅ Kommentare über deaktivierten Auto-Sync beibehalten

---

### 2. ✅ 4-TIER SUBSCRIPTION SYSTEM (PRODUCTION-READY)

**Implementiert:** FREE, PREMIUM, ELITE, ELITE_PRO (app.py:362-381)

**CURSOR DARF NICHT:**
- ❌ Subscription Levels reduzieren
- ❌ User Model Felder `subscription_type`, `subscription_updated_at`, `subscription_updated_by` entfernen

**CURSOR MUSS:**
- ✅ Alle 4 Levels bei neuen Features unterstützen
- ✅ `can_access_module()` für Zugriffsprüfung verwenden
- ✅ Admin-Audit-Log bei Subscription-Änderungen nutzen

---

### 3. 🔍 FEHLENDE MODULE AUTO-DETECTION

**Route:** `/admin/register-missing-modules` (app.py:5437-5532)

**CURSOR DARF NICHT:**
- ❌ Route löschen oder umbenennen
- ❌ "Neue Module" Kategorie (slug: `neue-module`) ändern
- ❌ Auto-Detection Logik entfernen

**CURSOR MUSS:**
- ✅ Fehlende Module als `is_published=False` registrieren
- ✅ System-Templates ignorieren (base.html, home.html, admin/*, auth/*)

---

### 4. 👥 USER MANAGEMENT & AUDIT LOGGING

**Interface:** `/admin/users` + `AdminAuditLog` Model

**CURSOR MUSS:**
- ✅ Audit-Log bei ALLEN User-Änderungen erstellen:
```python
audit_entry = AdminAuditLog(
    admin_username=session['username'],
    action_type='subscription_change',
    target_user_id=user.id,
    old_value=old_value,
    new_value=new_value
)
```

---

## ⚠️ KONFLIKT-PRÄVENTION

**Bei diesen Änderungen STOPPEN und User fragen:**
1. Module-Sync wiederherstellen
2. Subscription Levels reduzieren
3. User Model Schema ändern
4. Admin-Routes löschen/ändern
5. Auto-Detection Logik modifizieren
6. Audit-Logging deaktivieren

**✅ Sichere Bereiche:**
- Templates/Frontend (außer admin/users.html, admin/modules.html)
- Neue Features (ohne Core-Funktionen zu überschreiben)
- Styling/CSS
- Neue Lernmodule

---

## 📋 **MODUL-VERWALTUNG - AKTUELLER WORKFLOW**

### **Philosophie: Einfachheit über Komplexität**
- ✅ **Manuelle Kontrolle** statt fehleranfällige Automatisierung
- ✅ **Ein zuverlässiger Workflow**: Scan → Verschieben → Publishen
- ✅ **Admin hat volle Kontrolle**: Keine versteckten Auto-Prozesse

### **Kern-Workflow für neue Module:**

**Schritt-für-Schritt:**
```
1. HTML-Datei in /templates/*.html speichern
2. Commit & Push zu GitHub
3. Nach Deployment: /admin/modules aufrufen
4. Button "🔄 Neue Module scannen" klicken
5. Modul erscheint in "🆕 Neue Module" (is_published=False)
6. Modul in richtige Kategorie verschieben
7. Optional: publishen (is_published=True)
```

### **Scan-Funktion: `/admin/scan-new-modules`**

**Was die Route tut:**
- Scannt `templates/*.html` (ausgenommen System-Dateien)
- Findet Module, die NICHT in der DB sind
- Fügt sie zur "🆕 Neue Module" Kategorie hinzu
- Setzt `is_published=False` (unsichtbar für User)
- Zeigt klare Erfolgsmeldung mit Anzahl neuer Module

**System-Dateien die NICHT gescannt werden:**
```python
system_templates = {
    'base.html', 'login.html', 'register.html', 'index.html',
    'modules_overview.html', 'module_detail.html', 'admin_modules.html',
    '_navigation.html', 'home.html', 'upgrade_required.html'
    # Alle admin/*, auth/*, errors/* Templates
}
```

### **Admin-Interface Buttons (NUR 8 - NICHT MEHR!)**

**✅ BEHALTEN (die einzigen erlaubten):**
1. ➕ Hauptkategorie hinzufügen
2. ➕ Unterkategorie hinzufügen
3. 📄 Neues Modul hinzufügen
4. 🔄 Neue Module scannen (**HAUPT-FUNKTION!**)
5. ☑️ Bulk-Auswahl
6. 🗂️ Module-Übersicht
7. 🔄 Seite neu laden
8. 💾 Datenbank sichern

**❌ ENTFERNT (waren nicht zuverlässig - NICHT wieder hinzufügen!):**
- ❌ Auto-Sync bei Startup
- ❌ Komplexe Synchronisations-Routinen
- ❌ 60-Minuten-Timer mit Flag-Dateien
- ❌ Mehrere verschiedene Sync-Buttons
- ❌ Automatische Module-Registrierung

### **Wichtige Code-Locations (NICHT MODIFIZIEREN ohne User):**
- **Scan-Route:** `app.py` Zeile ~2634-2721
- **Admin-Buttons:** `templates/admin/modules.html` Zeile ~33-70
- **User Model:** `app.py` Zeile ~331-364
- **SubscriptionType Enum:** `app.py` Zeile ~332 (MUSS VOR User Model sein!)
- **Empty Subcategories:** `templates/modules_overview.html` Zeile ~89-105

### **Leere Unterkategorien-Regel (NUR für Admin sichtbar):**
```html
{% if subcategory.modules or (session.get('user', {}).get('username') in ['admin', 'didi']) %}
    <!-- Zeige Unterkategorie -->
    {% if not subcategory.modules %}
        <!-- Gelbes Banner nur für Admin -->
        <div style="background: #fef3c7; color: #92400e;">
            📭 Leere Unterkategorie (nur für Admin sichtbar)
        </div>
    {% endif %}
{% endif %}
```

---

## ⚠️ **KRITISCHE DATENBANK-REIHENFOLGE**

**ABSOLUT BEACHTEN - SONST CRASH BEI DEPLOYMENT!**

```python
# ✅ RICHTIGE REIHENFOLGE:

# 1. SubscriptionType Enum ZUERST (Zeile ~332)
class SubscriptionType(enum.Enum):
    FREE = "free"
    PREMIUM = "premium"
    ELITE = "elite"
    ELITE_PRO = "elite_pro"
    MASTERCLASS = "masterclass"

# 2. User Model DANACH (Zeile ~331-364)
class User(db.Model):
    subscription_type = db.Column(db.Enum(SubscriptionType),  # Verwendet Enum von oben!
                                  default=SubscriptionType.FREE,
                                  nullable=False)
    subscription_updated_at = db.Column(db.DateTime)
    subscription_updated_by = db.Column(db.String(80))

# 3. Module Models ZULETZT
class ModuleCategory(db.Model): ...
class ModuleSubcategory(db.Model): ...
class LearningModule(db.Model): ...
```

**❌ HÄUFIGER FEHLER - FÜHRT ZU RAILWAY CRASH:**
```python
# ❌ FALSCH: User Model vor SubscriptionType Enum
class User(db.Model):
    subscription_type = db.Column(db.Enum(SubscriptionType))  # NameError!
    
class SubscriptionType(enum.Enum):  # Zu spät definiert!
    FREE = "free"
```

**❌ WEITERER HÄUFIGER FEHLER:**
```python
# ❌ FALSCH: subscription_type als @property statt DB-Feld
@property
def subscription_type(self):
    return self._subscription_type  # Wird nicht in DB gespeichert!

# ✅ RICHTIG: Als db.Column
subscription_type = db.Column(db.Enum(SubscriptionType), ...)
```

---

## 🔧 **RAILWAY DEPLOYMENT - KRITISCHE CHECKS**

### **Bei Merge-Konflikten:**

**WICHTIG:** Immer die funktionierende Version aus vorheriger Session übernehmen statt neu zu implementieren!

**Beispiel:**
```
Problem: User-Verwaltung ging verloren nach Merge
❌ FALSCH: Neu implementieren (fehleranfällig, unterschiedlich)
✅ RICHTIG: Code aus funktionierendem Branch übernehmen
→ git checkout claude/prepare-production-release -- app.py
→ Nur relevante Teile übernehmen
```

### **Syntax-Check VOR jedem Commit:**

```bash
# IMMER ausführen vor git commit:
python3 -m py_compile app.py

# Falls Fehler: NICHT committen!
# Erst Fehler beheben, dann erneut prüfen
```

### **Testing nach Deployment (Checkliste):**

```bash
# 1. Modul-Scan testen
✅ /admin/modules → "🔄 Neue Module scannen" klicken
✅ Neue Module erscheinen in "🆕 Neue Module"

# 2. User-Management testen
✅ /admin/users → User mit verschiedenen Subscriptions hinzufügen
✅ Subscription-Änderungen funktionieren
✅ Audit-Log wird erstellt

# 3. Modul-Ansicht testen
✅ /modules → Leere Kategorien nur als Admin sichtbar
✅ Module basierend auf Subscription richtig angezeigt
```

---

## ✅ **BEST PRACTICES AUS DER PRAXIS**

### **DO's:**
- ✅ Einfache, zuverlässige Lösungen bevorzugen
- ✅ Admin behält manuelle Kontrolle
- ✅ Klare, verständliche Fehlermeldungen
- ✅ Bei Code-Restaurierung: Funktionierende Version aus Git übernehmen
- ✅ Syntax-Check vor jedem Commit: `python3 -m py_compile app.py`
- ✅ SubscriptionType Enum IMMER vor User Model
- ✅ Nur 8 Admin-Buttons (nicht mehr!)
- ✅ Scan-Funktion als Haupt-Tool für neue Module
- ✅ Routes in sicheren Zonen platzieren (>Zeile 1330)
- ✅ Vor app.py Änderungen: `git pull origin main`

### **DON'Ts:**
- ❌ Keine komplexen Auto-Sync-Routinen
- ❌ Keine 60-Minuten-Timer mit Flag-Dateien
- ❌ Keine read-only Properties für subscription_type
- ❌ Nicht mehrere SubscriptionType Enum Definitionen
- ❌ User Model NICHT vor SubscriptionType Enum
- ❌ Keine 14+ Buttons im Admin-Interface
- ❌ Keine automatische Module-Registrierung bei Startup
- ❌ Routes NICHT in Zeilen 1198-1210 einfügen (Konfliktzone)
- ❌ Ändern ohne vorheriges `git pull`

---

## Projekt-Übersicht
- Flask-basierte Web-App für Trading-Akademie
- Streamlit-Integration für interaktive Module
- SQLite-Datenbank für Benutzerdaten
- Authentifizierung und Modul-Management
- KONTEXT: Wir erstellen eine Hybrid-Lösung wo Flask die schönen Customer-facing Module übernimmt
- Pfad zur APP: cd "C:\Users\dietmar.breihof\OneDrive - Breihof-IT GmbH\Aktien\didis-premium-app"
- HTML-Seiten für das schöne Design (volle CSS-Kontrolle)
- Python-Backend für Logik, Datenverarbeitung, User-Management
- Template-System für dynamische Inhalte
- Die App soll irgendwann veröffentlich werden.
- HTML-Version für Marketing - Lead-Magnet, Website, Social Media
- Streamlit für interne Tools - Member-Dashboard, Analytics, Quick-Tools
- Oder HTML + JavaScript für beste User Experience

## Design System
- - Das Design vermittelt Professionalität und Exklusivität durch die Gold-Akzente, während die dunklen Farben Seriosität und die interaktiven Elemente Engagement fördern.
- Design-System Prompt für interaktive Lernseiten
Farbschema:
- Primärfarben: Dunkelgrau (#1a1a1a) als Hauptfarbe, mittleres Grau (#2d2d2d) als Sekundärfarbe
- Akzentfarben: Dunkles Gold (#b8860b), klassisches Gold (#daa520), helles Gold (#f4e97b)
- Funktionsfarben: Grün (#38a169) für Erfolg, Orange (#d69e2e) für Warnungen, Rot (#e53e3e) für Fehler
- Hintergrund: Helles Grau (#f7f7f7) für die Seite, Weiß (#ffffff) für Karten
- Farbverläufe: Primär-Verlauf von Dunkelgrau zu dunklem Gold, Gold-Verlauf zwischen verschiedenen Goldtönen
- Layout-Elemente: Maximale Seitenbreite: 1200px zentriert
- Einheitlicher Border-Radius: 12px für alle Karten und Buttons
- Schatten: Subtiler Schatten (0 4px 20px rgba(0, 0, 0, 0.1)) für Tiefeneffekt
- Abstände: 20px Standard-Padding, 40px für größere Bereiche

## Komponenten-Struktur:
- Header-Bereich: Großer Hero-Bereich mit Primär-Verlauf als Hintergrund, weiße Schrift, zentrierte Statistik-Karten mit Glasmorphismus-Effekt
- Fortschritts-Tracking: Weiße Karte mit Gold-Verlauf Fortschrittsbalken
- Aufklappbare Sektionen: Dunkle Header mit Gold-Akzenten, expandierende Inhalte mit Übergängen
- Interaktive Karten: Hover-Effekte mit Bewegung nach oben, Rahmen-Farbwechsel zu Gold
- Highlight-Boxen: Goldener Hintergrundverlauf mit dunkelgoldenem linkem Rand
- Warnboxen: Orange Hintergrundverlauf mit orangem linkem Rand

## Interaktivität:
- Sanfte Übergänge (0.3s ease) für alle Hover-Effekte
- Fade-in Animationen für Elemente beim Scrollen
- Aufklappbare Sektionen mit Höhen-Übergängen
- Auswählbare Karten mit visueller Bestätigung
- Fortschritts-Tracking mit lokaler Speicherung

## Typografie:
- Schriftart: Inter als primäre Schrift
- Hierarchie: Große Headlines (2.8em), mittlere Überschriften (1.4em), Standard-Text (1.05em)
- Zeilenhöhe: 1.6 für bessere Lesbarkeit

## Mobile Responsivität:
- Breakpoint bei 768px
- Stapelbare Grid-Layouts
- Angepasste Schriftgrößen und Abstände

## Projektplan
- Erstellung von interaktiven Lernseiten für die App
## Konkrete Implementierung:
Flask/FastAPI Integration

## Code-Stil
- Verwende deutsche Kommentare und Variablennamen wo sinnvoll
- Folge PEP 8 für Python-Code
- Verwende type hints wo möglich
- Dokumentiere komplexe Funktionen

## Architektur
- Flask für Web-Framework
- SQLAlchemy für Datenbank-ORM
- Jinja2 für Templates
- Session-basierte Authentifizierung

## Besondere Hinweise
- Die Haupt-App-Datei ist `app.py`
- Streamlit-Module werden in separaten Dateien gespeichert
- Admin-Funktionen sind in separaten Blueprints organisiert
- Templates verwenden Bootstrap für Styling
- Die HTML-Version verbessern (noch interaktiver, schöner)
- Die HTML-Version als Ansatz für customer-facing Content!
- Und formuliere in allen Texten die Anrede immer in der persönlich Anrede "Du"

## Verbote
- Keine hardcodierten Passwörter oder API-Keys
- Keine direkten SQL-Queries ohne ORM
- Keine unsicheren Session-Konfigurationen

## Debugging
- Verwende Flask's Debug-Modus für Entwicklung
- Logging über Python's logging-Modul
- Fehlerbehandlung mit try/except-Blöcken

# Lernmodul-Navigationssystem - Entwicklungsrichtlinien

Du bist ein Experte für moderne Web-UI/UX und entwickelst ein zeitgemäßes, benutzerfreundliches 3-Ebenen-Navigationssystem für interaktive Lernmodule.

## 🎯 Hauptziel
Erstelle ein intuitives, responsive Navigationssystem mit aufklappbaren Ebenen, automatischer Modul-Integration und komfortablen Admin-Funktionen.

## 🎨 Design-System (Pflicht)
### Farbschema:
- **Primärfarben**: Dunkelgrau (#1a1a1a), mittleres Grau (#2d2d2d)
- **Akzentfarben**: Dunkles Gold (#b8860b), klassisches Gold (#daa520), helles Gold (#f4e97b)
- **Funktionsfarben**: Grün (#38a169), Orange (#d69e2e), Rot (#e53e3e)
- **Hintergrund**: Helles Grau (#f7f7f7), Weiß (#ffffff) für Karten
- **Verläufe**: Primär-Verlauf (Dunkelgrau zu dunklem Gold), Gold-Verlauf

### Layout-Standards:
- Maximale Breite: 1200px zentriert
- Border-Radius: 12px einheitlich
- Schatten: 0 4px 20px rgba(0, 0, 0, 0.1)
- Abstände: 20px Standard, 40px für größere Bereiche
- Übergänge: 0.3s ease für alle Animationen

## 📱 Technische Anforderungen

### 3-Ebenen-Struktur:
1. **Hauptkategorien** (z.B. "Psychologie", "Grundlagen")
2. **Unterkategorien** (z.B. "Charttechnik", "Fundamentalanalyse")  
3. **Einzelmodule** (z.B. "Support & Resistance", "P/E Ratio verstehen")

### Aufklappbare Navigation:
- Smooth Accordion-Animation mit CSS transitions
- Pfeil-Icons die sich beim Aufklappen drehen
- Hierarchie durch Einrückung und Farbnuancen visualisieren
- Aktive/besuchte Module visuell hervorheben

### Auto-Integration neuer Module:
- Dynamische JSON/API-basierte Struktur
- Automatisches Hinzufügen ohne Code-Änderungen
- Sortierung nach Erstellungsdatum oder custom order
- Fallback für unzugeordnete Module

### Admin-Funktionen:
- Drag & Drop Sortierung mit visueller Rückmeldung
- Inline-Bearbeitung von Titeln und Beschreibungen
- Ein/Ausblenden von Modulen per Toggle
- Bulk-Aktionen für mehrere Module
- Änderungen sofort sichtbar (keine Seiten-Reload)

## 🔧 Implementierung

### Frontend (React/Vue/Vanilla JS):
```javascript
// Beispiel-Struktur für Menü-Daten
const menuStructure = {
  categories: [
    {
      id: 'trading-basics',
      title: 'Trading-Grundlagen',
      order: 1,
      expanded: false,
      subcategories: [
        {
          id: 'chart-analysis',
          title: 'Charttechnik',
          order: 1,
          modules: [
            {
              id: 'support-resistance',
              title: 'Support & Resistance',
              completed: true,
              progress: 100,
              order: 1
            }
          ]
        }
      ]
    }
  ]
}
```

### Responsive Verhalten:
- Desktop: Sidebar-Navigation (300px Breite)
- Tablet: Collapsible Sidebar
- Mobile: Bottom-Sheet oder Hamburger-Menü
- Touch-optimierte Tap-Bereiche (min. 44px)

### Accessibility:
- ARIA-Labels für Screen Reader
- Keyboard-Navigation (Tab, Enter, Pfeiltasten)
- Focus-Indikatoren in Gold-Akzentfarbe
- Semantisches HTML (nav, ul, li Struktur)

## 💡 UX-Features

### Fortschritts-Tracking:
- Visuelle Fortschrittsbalken pro Kategorie
- "X von Y Module abgeschlossen" Anzeige
- Completion-Badges in Gold für 100% Kategorien

### Such-/Filter-Funktionalität:
- Live-Suche durch alle Ebenen
- Filter nach Schwierigkeit/Status
- "Zuletzt besucht" Schnellzugriff

### Benutzerfreundlichkeit:
- Breadcrumb-Navigation
- "Nächstes Modul" Button
- Geschätzte Lernzeit pro Modul
- Bookmark-Funktion für wichtige Module

## 🎭 Interaktions-Design

### Hover-Effekte:
- Sanfte Farbübergänge zu Gold-Tönen
- Subtile Schatten-Verstärkung
- Cursor-Änderung für interaktive Elemente

### Loading-States:
- Skeleton-Loading für dynamische Inhalte
- Spinning-Icons in Gold für Lade-Vorgänge
- Smooth Fade-In für neue Module

### Animationen:
- Staggered Animations beim ersten Laden
- Bounce-Effekt für erfolgreich abgeschlossene Module
- Smooth Height-Transitions für Accordion

## 🔐 Admin-Interface

### Drag & Drop Editor:
- Visuelle Griffe (⋮⋮) für bewegbare Elemente
- Drop-Zones mit Gold-Highlighting
- Undo/Redo für Sortierungs-Änderungen
- Auto-Save mit visueller Bestätigung

### Bulk-Operations:
- Multi-Select mit Checkboxen
- "Alle auswählen" Toggle
- Batch-Aktionen: Verschieben, Löschen, Status ändern

## 📊 Performance & Daten

### Optimierung:
- Lazy Loading für nicht-sichtbare Ebenen
- Virtual Scrolling bei >100 Modulen
- Debounced Search (300ms)
- localStorage für UI-Präferenzen

### Daten-Struktur:
- RESTful API oder GraphQL
- Optimistic Updates für Admin-Änderungen
- Conflict Resolution bei gleichzeitigen Bearbeitungen
- Versionierung der Menü-Struktur

## ✅ Akzeptanzkriterien

### Must-Have:
- [ ] 3-Ebenen Navigation funktionsfähig
- [ ] Smooth Accordion-Animationen
- [ ] Drag & Drop Sortierung
- [ ] Responsive Design (Mobile-First)
- [ ] Auto-Integration neuer Module

### Nice-to-Have:
- [ ] Offline-Funktionalität
- [ ] Dark/Light Mode Toggle
- [ ] Keyboard Shortcuts
- [ ] Analytics für Nutzungsverhalten
- [ ] A/B Testing Framework

## 🚀 Entwicklungsvorgehen

1. **Wireframes** erstellen für alle Breakpoints
2. **Component Library** mit Design-System aufbauen
3. **Core Navigation** implementieren (ohne Admin)
4. **Admin-Features** stufenweise hinzufügen
5. **Performance Testing** und Optimierung
6. **User Testing** mit echten Lernmodulen

Verwende moderne Web-Standards, bevorzuge CSS Grid/Flexbox für Layout und sorge für eine intuitive, professionelle Benutzererfahrung die das Premium-Gefühl des Trading-Clubs widerspiegelt.

## 📚 Modul-Integration Workflow

### 🎯 Neue Module hinzufügen (3-Schritt-Prozess)

#### **Schritt 1: Template erstellen**
- Eigenständiges HTML-Template in `templates/` 
- Gold-Grau Design-System verwenden
- Inter-Font importieren
- Navigation zurück zu `/modules` einbauen

#### **Schritt 2: Route in app.py hinzufügen**
- Nach bestehenden Legacy Routes einfügen
- Standard-Pattern für Authentifizierung verwenden
- Progress-Tracking und View-Count implementieren

#### **Schritt 3: Datenbank-Eintrag erstellen**
```python
# Terminal-Command:
python -c "
from app import app, db, LearningModule, ModuleCategory
with app.app_context():
    category = ModuleCategory.query.filter_by(slug='KATEGORIE').first()
    module = LearningModule(
        category_id=category.id,
        title='Modul Titel',
        slug='modul-slug',
        description='Beschreibung',
        icon='🎯',
        content_type='html',
        template_file='template.html',
        is_published=True,
        is_lead_magnet=False,  # True für kostenlos
        required_subscription_levels=['premium', 'elite'],
        estimated_duration=60,
        difficulty_level='intermediate',
        sort_order=10
    )
    db.session.add(module)
    db.session.commit()
"
```

#### **Verfügbare Kategorien:**
- `technische-analyse` - `fundamentalanalyse` - `psychologie-mindset` - `risk-management` - `Investing System I` - `Elite - System III`

#### **Subscription Levels:**
- `[]` = kostenlos (Lead-Magnet)
- `['premium', 'elite']` = Premium-Module  
- `['elite']` = Nur Elite

#### **Difficulty Levels:**
- `beginner` (grün) - `intermediate` (orange) - `advanced` (rot)

### ✅ **Automatische Integration:**
- Module erscheinen automatisch in `/admin/modules`
- Werden in `/modules` unter gewählter Kategorie angezeigt
- Zugriffskontrolle basierend auf Subscription-Level
- Vollständig über Admin-Panel verwaltbar

## 🧭 **NAVIGATION-STANDARDS** 
**⚠️ PFLICHT: Jedes neue Modul MUSS die einheitliche Navigation enthalten!**

### 📍 **Für Flask-Templates (Empfohlen):**
```html
<!-- Am Ende jedes Moduls einfügen, VOR {% endblock %} -->
{% include '_navigation.html' %}
```

### 📍 **Für base.html-Templates (extends "base.html"):**
```html
<!-- Innerhalb des {% block content %} Blocks, VOR {% endblock %} -->
{% block content %}
    <!-- Modul-Inhalt hier -->
    
    <!-- Navigation am Ende hinzufügen -->
    {% include '_navigation.html' %}
{% endblock %}
```

### 📍 **Für Standalone HTML-Dateien:**
```html
<!-- VOR </body> Tag einfügen -->
<!-- Einheitliche Navigation -->
{% include '_navigation.html' %}
```

### 📍 **Für spezifische Routes (z.B. /marktampel-allokation):**
```python
@app.route('/mein-modul')
def mein_modul():
    # Modul aus Datenbank laden (falls vorhanden)
    module = LearningModule.query.filter_by(slug='mein-modul').first()
    
    # WICHTIG: Admin-Zugriffskontrolle hinzufügen
    if module:
        username = session.get('user', {}).get('username')
        is_admin = username in ['admin', 'didi']
        user_subscription = session.get('user', {}).get('membership', 'free')
        
        if not is_admin and not module.user_has_access(user_subscription):
            return redirect(url_for('upgrade_required', module_slug='mein-modul'))
    
    # WICHTIG: Navigation-Daten übergeben
    prev_module, next_module = get_module_navigation(module) if module else (None, None)
    
    return render_template('mein_template.html', 
                         module=module, 
                         prev_module=prev_module, 
                         next_module=next_module)
```

### 🚨 **KRITISCHE WARNUNGEN:**
- **NIEMALS** Jinja2-Syntax in HTML-Kommentaren verwenden (führt zu Recursion-Fehlern)
- **IMMER** Navigation vor schließendem `{% endblock %}` einfügen
- **PRÜFEN** ob Module base.html erweitern (andere Implementierung erforderlich)

### 🔒 **Admin-Zugriffskontrolle (AUTOMATISCH):**
- **Admin/Didi** haben automatisch Zugriff auf ALLE Module (auch Elite)
- **Admin-Link** nur für `admin` und `didi` sichtbar
- **Premium-CTAs** werden für Admin/Didi ausgeblendet
- **Flask**: Automatisch über `_navigation.html`
- **JavaScript**: `fetch('/api/check-admin')` für standalone HTML

### 📋 **Vollständige Checkliste für jedes neue Modul:**
- [ ] **Template-Typ identifiziert**: Standalone HTML, Flask-Template, base.html-Extension oder spezifische Route?
- [ ] **Route-Typ bestimmt**: `/module/<slug>` (Standard) oder spezifische Route (z.B. `/marktampel-allokation`)?
- [ ] Navigation eingefügt (`{% include '_navigation.html' %}`)
- [ ] **Position korrekt**: VOR `{% endblock %}` oder VOR `</body>`
- [ ] **Navigation-Daten in Route übergeben**: `prev_module`, `next_module` Parameter
- [ ] **Admin-Zugriffskontrolle in Route**: `is_admin = username in ['admin', 'didi']`
- [ ] **get_module_navigation() robustheit**: Funktioniert mit temporären und echten Modulen
- [ ] **Hauptnavigation** funktioniert (🏠 Startseite, 📚 Module, 🔧 Admin, 🚀 Hauptapp)
- [ ] **Weiter/Zurück-Navigation** zwischen Modulen funktioniert (falls DB-Modul)
- [ ] **Admin-Zugriff** automatisch gewährt (keine Premium-CTAs für admin/didi)
- [ ] Links funktionieren und sind korrekt verlinkt
- [ ] Responsive Design auf Mobile getestet
- [ ] Module-Reihenfolge in Datenbank korrekt (sort_order)
- [ ] **Keine Jinja2-Syntax** in HTML-Kommentaren verwendet

### 🐛 **HÄUFIGE FEHLERQUELLEN (VERMEIDEN!):**

**1. Jinja2-Recursion-Fehler:**
```html
<!-- ❌ FALSCH: Führt zu Recursion -->
<!-- Verwendung: {% include '_navigation.html' %} -->

<!-- ✅ RICHTIG: Keine Jinja2-Syntax in Kommentaren -->
<!-- Verwendung: Diese Datei mit include einbinden -->
```

**2. Fehlende Navigation in base.html-Templates:**
```html
<!-- ❌ FALSCH: Navigation vergessen -->
{% extends "base.html" %}
{% block content %}
    <!-- Inhalt -->
{% endblock %}

<!-- ✅ RICHTIG: Navigation hinzugefügt -->
{% extends "base.html" %}
{% block content %}
    <!-- Inhalt -->
    {% include '_navigation.html' %}
{% endblock %}
```

**3. Admin-Zugriff nicht berücksichtigt:**
```python
# ❌ FALSCH: Admin sieht Premium-CTAs
if not module.user_has_access(user_subscription):
    return redirect('upgrade_required')

# ✅ RICHTIG: Admin-Exception
is_admin = username in ['admin', 'didi']
if not is_admin and not module.user_has_access(user_subscription):
    return redirect('upgrade_required')
```

**4. Fehlende Navigation-Daten in spezifischen Routes:**
```python
# ❌ FALSCH: Navigation-Daten nicht übergeben
@app.route('/mein-modul')
def mein_modul():
    module = LearningModule.query.filter_by(slug='mein-modul').first()
    return render_template('mein_template.html', module=module)

# ✅ RICHTIG: Navigation-Daten übergeben
@app.route('/mein-modul')
def mein_modul():
    module = LearningModule.query.filter_by(slug='mein-modul').first()
    prev_module, next_module = get_module_navigation(module) if module else (None, None)
    return render_template('mein_template.html', 
                         module=module, 
                         prev_module=prev_module, 
                         next_module=next_module)
```

**5. Nicht-robuste Navigation-Funktion:**
```python
# ❌ FALSCH: Crash bei temporären Modulen
def get_module_navigation(current_module):
    modules = LearningModule.query.filter_by(
        category_id=current_module.category_id  # AttributeError!
    ).all()

# ✅ RICHTIG: Robuste Implementierung
def get_module_navigation(current_module):
    if not hasattr(current_module, 'category_id'):
        return None, None  # Temporäres Modul
    # ... rest der Logik
```

**📖 Vollständige Dokumentation: `NAVIGATION_STANDARDS.md`**

---

## 🚨 **KRITISCHE SICHERHEITSMÄNGEL**

### 1. **Passwort-Sicherheit**
```python
# ❌ AKTUELL: Klartext-Passwörter
demo_users = {
    'admin': {'password': 'admin', ...},
    'didi': {'password': 'didi', ...}
}
```

**🔧 Erforderlich:**
- **Passwort-Hashing** mit `werkzeug.security` (bereits in `database.py` vorbereitet!)
- **Starke Passwort-Richtlinien** (min. 8 Zeichen, Sonderzeichen)
- **Passwort-Reset-Funktionalität**

### 2. **Session-Sicherheit**
```python
# ❌ AKTUELL: Schwacher Secret Key
app.secret_key = 'dein-geheimer-schluessel-hier-aendern'
```

**🔧 Erforderlich:**
- **Kryptographisch sicherer Secret Key** (32+ Bytes)
- **Session-Timeout-Konfiguration**
- **Secure Cookie Settings** (HTTPS-only)

### 3. **CSRF-Schutz**
❌ **Komplett fehlend** - Alle Formulare sind anfällig für Cross-Site Request Forgery

**🔧 Erforderlich:**
- **Flask-WTF** Integration
- **CSRF-Tokens** in allen Formularen

### 4. **SQL-Injection-Schutz**
✅ **Gut:** SQLAlchemy ORM wird korrekt verwendet

### 5. **Input-Validierung**
❌ **Fehlend:** Keine Validierung von Benutzereingaben

## 📋 **BEWERTUNG DER AKTUELLEN ARCHITEKTUR**

### ✅ **Positive Aspekte:**
1. **Solide Datenbankstruktur** mit SQLAlchemy ORM
2. **Gute Trennung** zwischen Demo- und echten Benutzern
3. **Subscription-System** ist durchdacht implementiert
4. **Modularer Aufbau** ermöglicht einfache Erweiterungen

### ❌ **Produktionsreife-Blocker:**
1. **Keine echte Benutzerverwaltung** (nur Demo-Accounts)
2. **Fehlende Registrierung** (register.html ist leer!)
3. **Keine Email-Verifizierung**
4. **Keine Passwort-Recovery**
5. **Fehlende Rate-Limiting** gegen Brute-Force
6. **Keine Audit-Logs**

## 🛠️ **ROADMAP FÜR PRODUKTIONSREIFE**

### **Phase 1: Kritische Sicherheit (SOFORT)**
```python
# 1. Sicherer Secret Key
import secrets
app.secret_key = secrets.token_hex(32)

# 2. CSRF-Schutz
from flask_wtf.csrf import CSRFProtect
csrf = CSRFProtect(app)

# 3. Session-Konfiguration
app.config.update(
    SESSION_COOKIE_SECURE=True,  # HTTPS only
    SESSION_COOKIE_HTTPONLY=True,  # No JS access
    SESSION_COOKIE_SAMESITE='Lax',
    PERMANENT_SESSION_LIFETIME=timedelta(hours=2)
)
```

### **Phase 2: Echte Benutzerverwaltung**
```python
# User Registration Route
@app.route('/register', methods=['GET', 'POST'])
def register():
    # Implementierung mit Passwort-Hashing
    # Email-Validierung
    # Unique-Constraints prüfen
    
# Login mit gehashten Passwörtern
def login():
    user = User.query.filter_by(email=email).first()
    if user and user.check_password(password):
        # Login erfolgreich
```

### **Phase 3: Email-System**
```python
# Flask-Mail Integration
from flask_mail import Mail, Message

# Email-Verifizierung
# Passwort-Reset
# Welcome-Emails
```

### **Phase 4: Erweiterte Sicherheit**
- **Rate Limiting** mit Flask-Limiter
- **Two-Factor Authentication**
- **Audit Logging**
- **Input Sanitization**

## 💡 **SOFORT-EMPFEHLUNGEN**

### 1. **Nutzen Sie die vorhandene User-Klasse**
Die `database.py` enthält bereits eine **professionelle User-Klasse** mit:
- Passwort-Hashing (`set_password`, `check_password`)
- Subscription-Management
- Email-Verifizierung (Felder vorhanden)

### 2. **Implementieren Sie echte Registrierung**
```python
# templates/auth/register.html ist leer - hier implementieren!
```

### 3. **Environment Variables**
```python
# Für Produktion
import os
app.secret_key = os.environ.get('SECRET_KEY') or secrets.token_hex(32)
```

## 🎯 **FAZIT**

**Aktuelle Bewertung: ❌ NICHT produktionsreif**

**Hauptprobleme:**
- Nur Demo-Accounts, keine echten Benutzer
- Kritische Sicherheitslücken (CSRF, schwache Session-Sicherheit)
- Fehlende Registrierung/Email-Verifizierung

**Zeitaufwand für Produktionsreife:** 
- **Minimum:** 2-3 Wochen (kritische Sicherheit + Basis-Funktionen)
- **Empfohlen:** 4-6 Wochen (vollständige, sichere Implementierung)

**Nächste Schritte:**
1. **SOFORT:** Secret Key und CSRF-Schutz
2. **Woche 1:** Echte User-Registration implementieren
3. **Woche 2:** Email-System und Passwort-Recovery
4. **Woche 3-4:** Testing und Security-Hardening

Soll ich Ihnen bei der Implementierung einer sicheren Benutzerverwaltung helfen? Ich kann konkrete Code-Beispiele für die kritischen Bereiche erstellen.

---

## 🤝 **PARALLELE ENTWICKLUNG: CURSOR + CLAUDE CODE**

### 🎯 **Übersicht**
Um Merge-Konflikte und Inkonsistenzen zu vermeiden, wenn parallel mit Cursor und Claude Code gearbeitet wird.

**Grundprinzip:** Claude Code Änderungen haben VORRANG!

---

### 📍 **KONFLIKTPOTENTIALE IN APP.PY**

#### **Kritischer Bereich: Routes zwischen Zeile 1198-1210**

**Aktuelle Struktur:**
```
Zeile 1198: @app.route('/symmetrie-trading')          # Lead-Magnet Route
Zeile 1209: (Ende der Route)
Zeile 1210: # Legacy Routes (kompatibel mit bestehender App)
Zeile 1212: @app.route('/marktampel-allokation')      # Erste Legacy Route
```

**Konfliktzone:**
- Neue Routes zwischen `symmetrie-trading` (1198) und Legacy-Kommentar (1210)
- Zeilennummern verschieben sich bei jeder Änderung
- Mehrere Entwicklungstools = Merge-Konflikte

---

### 🛡️ **CURSOR REGELN FÜR APP.PY**

#### **1. Route-Hinzufügung: STRENGE POSITIONIERUNG**

**❌ VERBOTEN:**
```python
# Keine Routes zwischen symmetrie-trading und # Legacy Routes einfügen!
```

**✅ ERLAUBT - Option A: Nach Legacy Routes**
```python
@app.route('/symmetrie-trading')
def symmetrie_trading():
    ...

# Legacy Routes (kompatibel mit bestehender App)  ← NICHT BERÜHREN

@app.route('/marktampel-allokation')
def marktampel_allokation():
    ...

# ✅ HIER neue Premium-Routes einfügen (nach allen Legacy Routes)
@app.route('/position-vergroessern')  # Cursor-Route
def position_vergroessern():
    """Position vergrößern - Lance's Expected-Value-Methode"""
    track_visitor()
    user_subscription = "free"
    username = None
    if session.get('logged_in'):
        user_subscription = session.get('user', {}).get('membership', 'free')
        username = session.get('user', {}).get('username')
    is_admin = username in ['admin', 'didi']
    if not is_admin and user_subscription not in ['premium', 'elite']:
        flash('Für dieses Modul benötigst du ein Premium-Abonnement.', 'warning')
        return redirect(url_for('upgrade_required', module_slug='position-vergroessern'))
    return render_template('position-vergroessern.html')
```

**✅ ERLAUBT - Option B: Vor symmetrie-trading (für Lead-Magnets)**
```python
@app.route('/volume-analyse-grundlagen')
def volume_analyse_grundlagen():
    ...

# ✅ HIER neue Lead-Magnet Routes einfügen
@app.route('/neue-lead-magnet-route')
def neue_lead_magnet():
    track_visitor()
    return render_template('neue-route.html')

@app.route('/symmetrie-trading')  # Letzte Lead-Magnet Route
def symmetrie_trading():
    ...
```

---

### 🔧 **ROUTE-PATTERNS: WELCHES VERWENDEN?**

#### **Pattern 1: Lead-Magnet (Öffentlich zugänglich)**
```python
@app.route('/modul-name')
def modul_name():
    """Beschreibung"""
    track_visitor()  # Analytics
    return render_template('modul-name.html')
```

**Verwendung:** Kostenlose Module, Marketinginhalte
**Position:** VOR symmetrie-trading (Zeile ~1186-1198)

---

#### **Pattern 2: Premium Direct (Ohne DB-Dependency)**
```python
@app.route('/modul-name')
def modul_name():
    """Beschreibung"""
    track_visitor()  # Analytics

    # Zugriff prüfen (Premium Content)
    user_subscription = "free"
    username = None
    if session.get('logged_in'):
        user_subscription = session.get('user', {}).get('membership', 'free')
        username = session.get('user', {}).get('username')

    # Admin und Didi haben immer Zugriff auf alle Module
    is_admin = username in ['admin', 'didi']

    # Prüfe Premium/Elite-Zugriff
    if not is_admin and user_subscription not in ['premium', 'elite']:
        flash('Für dieses Modul benötigst du ein Premium-Abonnement.', 'warning')
        return redirect(url_for('upgrade_required', module_slug='modul-name'))

    return render_template('modul-name.html')
```

**Verwendung:** Premium-Module ohne DB-Integration
**Position:** NACH allen Legacy Routes (Zeile >1270)
**Beispiele:** `/expected-value`, `/position-vergroessern`

---

#### **Pattern 3: Legacy mit DB-Integration (Komplex)**
```python
@app.route('/modul-name')
def modul_name():
    """Beschreibung"""
    module_slug = 'modul-name'

    try:
        module = LearningModule.query.filter_by(slug=module_slug, is_published=True).first()
    except:
        module = None

    # Zugriff prüfen (falls über Modul-System)
    if module:
        user_subscription = "free"
        username = None
        if session.get('logged_in'):
            user_subscription = session.get('user', {}).get('membership', 'free')
            username = session.get('user', {}).get('username')

        is_admin = username in ['admin', 'didi']

        if not is_admin and not module.user_has_access(user_subscription):
            flash('Für dieses Modul benötigst du ein Premium-Abonnement.', 'warning')
            return redirect(url_for('upgrade_required', module_slug=module_slug))

        # Progress tracking
        if session.get('logged_in'):
            user_id = session.get('user_id', 'anonymous')
            # ... Progress Logic

    return render_template('modul-name.html')
```

**Verwendung:** Legacy-Module mit DB-Anbindung
**Position:** Legacy Routes Bereich (Zeile 1212-1270)
**Beispiele:** `/marktampel-allokation`

---

### ⚠️ **KRITISCHE REGELN**

#### **1. NIEMALS diese Zeilen ändern:**
```python
# Zeile 1210 - Wichtiger Orientierungspunkt
# Legacy Routes (kompatibil mit bestehender App)
```

#### **2. NIEMALS zwischen diesen Routen einfügen:**
- `@app.route('/symmetrie-trading')` (Zeile 1198)
- `# Legacy Routes` Kommentar (Zeile 1210)
- Nur 11 Zeilen Abstand = extrem konfliktanfällig!

#### **3. Route-Reihenfolge beibehalten:**
```
[Lead-Magnet Routes]
    ↓
@app.route('/symmetrie-trading')  ← LETZTE Lead-Magnet Route
    ↓
# Legacy Routes  ← MARKER (nicht verschieben!)
    ↓
[Legacy Routes mit DB-Integration]
    ↓
[Premium Direct Routes]  ← CURSOR fügt hier ein
    ↓
[Admin Routes]
```

---

### 🚨 **MERGE-KONFLIKT-VERMEIDUNG**

#### **Vor dem Commit:**

1. **Git Status prüfen:**
```bash
git status
git diff app.py
```

2. **Claude Code Änderungen fetchen:**
```bash
git fetch origin
git log origin/claude/... --oneline -5  # Neueste Claude Commits
```

3. **Nur lokale Änderungen committen wenn:**
   - ✅ Keine parallelen Claude Code Commits in app.py
   - ✅ Eigene Routes in sicheren Bereichen (NACH Legacy Routes)
   - ✅ Keine Zeilenverschiebungen im Konfliktbereich (1198-1210)

4. **Bei Unsicherheit:**
```bash
# Änderungen stashen
git stash

# Claude Änderungen pullen
git pull origin <claude-branch>

# Eigene Änderungen wieder anwenden
git stash pop

# Konflikte manuell lösen
```

---

### 📋 **CHECKLISTE: NEUE ROUTE HINZUFÜGEN (CURSOR)**

- [ ] **Route-Typ bestimmt:** Lead-Magnet, Premium Direct oder Legacy?
- [ ] **Position gewählt:**
  - Lead-Magnet → VOR symmetrie-trading (Zeile <1198)
  - Premium Direct → NACH Legacy Routes (Zeile >1270)
  - Legacy → Im Legacy-Bereich (1212-1270) - nur wenn nötig!
- [ ] **Pattern korrekt verwendet:**
  - Lead-Magnet: `track_visitor()` + `render_template()`
  - Premium: Admin-Check + Subscription-Check
  - Legacy: DB-Query + Progress Tracking
- [ ] **Template existiert:** `templates/modul-name.html` erstellt
- [ ] **Migration vorbereitet:** `migrations/register_*.py` erstellt
- [ ] **Admin-Bypass implementiert:** `is_admin = username in ['admin', 'didi']`
- [ ] **Analytics aktiviert:** `track_visitor()` aufgerufen
- [ ] **Git Check durchgeführt:**
  - `git fetch origin` ausgeführt
  - Keine parallelen Claude Commits in app.py
  - Diff geprüft: `git diff app.py`
- [ ] **Commit Message klar:** "feat(cursor): Add [Modul-Name] route"

---

### 💡 **BESTE PRAKTIKEN**

#### **1. Kommunikation über Git:**
```bash
# Guter Commit-Titel (Cursor)
git commit -m "feat(cursor): Add position-vergroessern module"

# Guter Commit-Titel (Claude Code)
git commit -m "feat(claude): Add trading-archetypen module"
```

#### **2. Separate Branches für experimentelle Features:**
```bash
# Cursor experimentiert
git checkout -b cursor/experiment-feature

# Claude Code bleibt auf Main-Branch
# Merge erst nach Abstimmung
```

#### **3. Regelmäßig synchronisieren:**
```bash
# Alle 30 Minuten
git fetch origin
git status
```

---

### 🎯 **DEIN CURSOR-MODUL: position-vergroessern**

**Status:** ✅ Pattern korrekt, aber Position konfliktanfällig

**Aktuell geplante Position (Cursor):**
```
Zeile 1198: @app.route('/symmetrie-trading')
Zeile 1209: (Ende symmetrie-trading)
Zeile 1028-1048: @app.route('/position-vergroessern')  ← KONFLIKTZONE!
Zeile 1210: # Legacy Routes
```

**🚨 PROBLEM:** Du versuchst zwischen Zeile 1209 und 1210 einzufügen - nur 1 Zeile Abstand!

**✅ LÖSUNG:** Route NACH allen Legacy Routes verschieben

**Empfohlene Position:**
```
# Nach /expected-value (Zeile ~1330)
@app.route('/position-vergroessern')
def position_vergroessern():
    """Position vergrößern - Lance's Expected-Value-Methode"""
    track_visitor()
    user_subscription = "free"
    username = None
    if session.get('logged_in'):
        user_subscription = session.get('user', {}).get('membership', 'free')
        username = session.get('user', {}).get('username')
    is_admin = username in ['admin', 'didi']
    if not is_admin and user_subscription not in ['premium', 'elite']:
        flash('Für dieses Modul benötigst du ein Premium-Abonnement.', 'warning')
        return redirect(url_for('upgrade_required', module_slug='position-vergroessern'))
    return render_template('position-vergroessern.html')
```

**Position:** Nach `/expected-value` (Zeile ~1330) oder nach `/ev-calculator` (Zeile ~1350)

---

### 📊 **ZUSAMMENFASSUNG**

**Konfliktpotential:** 🔴 HOCH (wenn in Zeile 1198-1210 eingefügt)

**Empfohlene Maßnahmen:**
1. ✅ Route NACH Legacy Routes verschieben (Zeile >1330)
2. ✅ Pattern "Premium Direct" beibehalten (ist korrekt)
3. ✅ Vor Commit: `git fetch && git diff app.py` prüfen
4. ✅ Klare Commit-Message: `feat(cursor): Add position-vergroessern module`

**Mit diesen Regeln: Konfliktpotential → 🟢 NIEDRIG**
